// Code generated by protoc-gen-go. DO NOT EDIT.
// source: workscheduler/workscheduler.proto

package workscheduler

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Work - a description of the work item to process
type Work struct {
	// describes the source of the work.
	Source *WorkSource `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// describes the work to perform.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	// describes directions on how to perform the work
	Directions []byte `protobuf:"bytes,3,opt,name=directions,proto3" json:"directions,omitempty"`
	// describes if the work *may* have been attempted before
	Reattempt            bool     `protobuf:"varint,4,opt,name=reattempt,proto3" json:"reattempt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Work) Reset()         { *m = Work{} }
func (m *Work) String() string { return proto.CompactTextString(m) }
func (*Work) ProtoMessage()    {}
func (*Work) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b6ef79e9ae4cedb, []int{0}
}

func (m *Work) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Work.Unmarshal(m, b)
}
func (m *Work) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Work.Marshal(b, m, deterministic)
}
func (m *Work) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Work.Merge(m, src)
}
func (m *Work) XXX_Size() int {
	return xxx_messageInfo_Work.Size(m)
}
func (m *Work) XXX_DiscardUnknown() {
	xxx_messageInfo_Work.DiscardUnknown(m)
}

var xxx_messageInfo_Work proto.InternalMessageInfo

func (m *Work) GetSource() *WorkSource {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Work) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Work) GetDirections() []byte {
	if m != nil {
		return m.Directions
	}
	return nil
}

func (m *Work) GetReattempt() bool {
	if m != nil {
		return m.Reattempt
	}
	return false
}

type WorkSource struct {
	// describes the source of the work.  May encode the kafka topic and partition and offset.
	Source               string   `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkSource) Reset()         { *m = WorkSource{} }
func (m *WorkSource) String() string { return proto.CompactTextString(m) }
func (*WorkSource) ProtoMessage()    {}
func (*WorkSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b6ef79e9ae4cedb, []int{1}
}

func (m *WorkSource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkSource.Unmarshal(m, b)
}
func (m *WorkSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkSource.Marshal(b, m, deterministic)
}
func (m *WorkSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkSource.Merge(m, src)
}
func (m *WorkSource) XXX_Size() int {
	return xxx_messageInfo_WorkSource.Size(m)
}
func (m *WorkSource) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkSource.DiscardUnknown(m)
}

var xxx_messageInfo_WorkSource proto.InternalMessageInfo

func (m *WorkSource) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

// LagResponse - how much the work scheduler is lagging
type LagResponse struct {
	// the timestamp of the oldest message not yet processed
	MyField              *timestamp.Timestamp `protobuf:"bytes,1,opt,name=my_field,json=myField,proto3" json:"my_field,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *LagResponse) Reset()         { *m = LagResponse{} }
func (m *LagResponse) String() string { return proto.CompactTextString(m) }
func (*LagResponse) ProtoMessage()    {}
func (*LagResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b6ef79e9ae4cedb, []int{2}
}

func (m *LagResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LagResponse.Unmarshal(m, b)
}
func (m *LagResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LagResponse.Marshal(b, m, deterministic)
}
func (m *LagResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LagResponse.Merge(m, src)
}
func (m *LagResponse) XXX_Size() int {
	return xxx_messageInfo_LagResponse.Size(m)
}
func (m *LagResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LagResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LagResponse proto.InternalMessageInfo

func (m *LagResponse) GetMyField() *timestamp.Timestamp {
	if m != nil {
		return m.MyField
	}
	return nil
}

type WorkOutput struct {
	Id                   *KafkaOutput `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *WorkOutput) Reset()         { *m = WorkOutput{} }
func (m *WorkOutput) String() string { return proto.CompactTextString(m) }
func (*WorkOutput) ProtoMessage()    {}
func (*WorkOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b6ef79e9ae4cedb, []int{3}
}

func (m *WorkOutput) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkOutput.Unmarshal(m, b)
}
func (m *WorkOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkOutput.Marshal(b, m, deterministic)
}
func (m *WorkOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkOutput.Merge(m, src)
}
func (m *WorkOutput) XXX_Size() int {
	return xxx_messageInfo_WorkOutput.Size(m)
}
func (m *WorkOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkOutput.DiscardUnknown(m)
}

var xxx_messageInfo_WorkOutput proto.InternalMessageInfo

func (m *WorkOutput) GetId() *KafkaOutput {
	if m != nil {
		return m.Id
	}
	return nil
}

type KafkaOutput struct {
	KafkaTopicMessages   []*KafkaTopicMessages `protobuf:"bytes,1,rep,name=kafkaTopicMessages,proto3" json:"kafkaTopicMessages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *KafkaOutput) Reset()         { *m = KafkaOutput{} }
func (m *KafkaOutput) String() string { return proto.CompactTextString(m) }
func (*KafkaOutput) ProtoMessage()    {}
func (*KafkaOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b6ef79e9ae4cedb, []int{4}
}

func (m *KafkaOutput) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KafkaOutput.Unmarshal(m, b)
}
func (m *KafkaOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KafkaOutput.Marshal(b, m, deterministic)
}
func (m *KafkaOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KafkaOutput.Merge(m, src)
}
func (m *KafkaOutput) XXX_Size() int {
	return xxx_messageInfo_KafkaOutput.Size(m)
}
func (m *KafkaOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_KafkaOutput.DiscardUnknown(m)
}

var xxx_messageInfo_KafkaOutput proto.InternalMessageInfo

func (m *KafkaOutput) GetKafkaTopicMessages() []*KafkaTopicMessages {
	if m != nil {
		return m.KafkaTopicMessages
	}
	return nil
}

type KafkaTopicMessages struct {
	Topic                string                    `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	PartitionMessages    []*KafkaPartitionMessages `protobuf:"bytes,2,rep,name=partitionMessages,proto3" json:"partitionMessages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *KafkaTopicMessages) Reset()         { *m = KafkaTopicMessages{} }
func (m *KafkaTopicMessages) String() string { return proto.CompactTextString(m) }
func (*KafkaTopicMessages) ProtoMessage()    {}
func (*KafkaTopicMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b6ef79e9ae4cedb, []int{5}
}

func (m *KafkaTopicMessages) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KafkaTopicMessages.Unmarshal(m, b)
}
func (m *KafkaTopicMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KafkaTopicMessages.Marshal(b, m, deterministic)
}
func (m *KafkaTopicMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KafkaTopicMessages.Merge(m, src)
}
func (m *KafkaTopicMessages) XXX_Size() int {
	return xxx_messageInfo_KafkaTopicMessages.Size(m)
}
func (m *KafkaTopicMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_KafkaTopicMessages.DiscardUnknown(m)
}

var xxx_messageInfo_KafkaTopicMessages proto.InternalMessageInfo

func (m *KafkaTopicMessages) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *KafkaTopicMessages) GetPartitionMessages() []*KafkaPartitionMessages {
	if m != nil {
		return m.PartitionMessages
	}
	return nil
}

type KafkaPartitionMessages struct {
	Partition            int32           `protobuf:"varint,1,opt,name=partition,proto3" json:"partition,omitempty"`
	Messages             []*KafkaMessage `protobuf:"bytes,2,rep,name=messages,proto3" json:"messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *KafkaPartitionMessages) Reset()         { *m = KafkaPartitionMessages{} }
func (m *KafkaPartitionMessages) String() string { return proto.CompactTextString(m) }
func (*KafkaPartitionMessages) ProtoMessage()    {}
func (*KafkaPartitionMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b6ef79e9ae4cedb, []int{6}
}

func (m *KafkaPartitionMessages) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KafkaPartitionMessages.Unmarshal(m, b)
}
func (m *KafkaPartitionMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KafkaPartitionMessages.Marshal(b, m, deterministic)
}
func (m *KafkaPartitionMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KafkaPartitionMessages.Merge(m, src)
}
func (m *KafkaPartitionMessages) XXX_Size() int {
	return xxx_messageInfo_KafkaPartitionMessages.Size(m)
}
func (m *KafkaPartitionMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_KafkaPartitionMessages.DiscardUnknown(m)
}

var xxx_messageInfo_KafkaPartitionMessages proto.InternalMessageInfo

func (m *KafkaPartitionMessages) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *KafkaPartitionMessages) GetMessages() []*KafkaMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type KafkaMessage struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KafkaMessage) Reset()         { *m = KafkaMessage{} }
func (m *KafkaMessage) String() string { return proto.CompactTextString(m) }
func (*KafkaMessage) ProtoMessage()    {}
func (*KafkaMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b6ef79e9ae4cedb, []int{7}
}

func (m *KafkaMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KafkaMessage.Unmarshal(m, b)
}
func (m *KafkaMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KafkaMessage.Marshal(b, m, deterministic)
}
func (m *KafkaMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KafkaMessage.Merge(m, src)
}
func (m *KafkaMessage) XXX_Size() int {
	return xxx_messageInfo_KafkaMessage.Size(m)
}
func (m *KafkaMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_KafkaMessage.DiscardUnknown(m)
}

var xxx_messageInfo_KafkaMessage proto.InternalMessageInfo

func (m *KafkaMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*Work)(nil), "workscheduler.Work")
	proto.RegisterType((*WorkSource)(nil), "workscheduler.WorkSource")
	proto.RegisterType((*LagResponse)(nil), "workscheduler.LagResponse")
	proto.RegisterType((*WorkOutput)(nil), "workscheduler.WorkOutput")
	proto.RegisterType((*KafkaOutput)(nil), "workscheduler.KafkaOutput")
	proto.RegisterType((*KafkaTopicMessages)(nil), "workscheduler.KafkaTopicMessages")
	proto.RegisterType((*KafkaPartitionMessages)(nil), "workscheduler.KafkaPartitionMessages")
	proto.RegisterType((*KafkaMessage)(nil), "workscheduler.KafkaMessage")
}

func init() {
	proto.RegisterFile("workscheduler/workscheduler.proto", fileDescriptor_6b6ef79e9ae4cedb)
}

var fileDescriptor_6b6ef79e9ae4cedb = []byte{
	// 518 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x51, 0x8f, 0xd2, 0x40,
	0x10, 0xa6, 0xd0, 0x43, 0x6e, 0xb8, 0x7b, 0x70, 0x34, 0x04, 0x39, 0xa3, 0xdc, 0x46, 0x13, 0x62,
	0x62, 0x1b, 0xb9, 0x10, 0x49, 0x8c, 0x2f, 0xa7, 0xde, 0x8b, 0x67, 0xe4, 0x96, 0x4b, 0x4c, 0x7c,
	0xd1, 0xa5, 0x5d, 0x7a, 0x1b, 0x5a, 0x76, 0xd3, 0x6e, 0x63, 0x78, 0xf2, 0x07, 0xf8, 0x77, 0xfc,
	0x81, 0x97, 0xb6, 0x40, 0x29, 0x14, 0x1e, 0xee, 0xad, 0xfb, 0xcd, 0x37, 0xf3, 0x7d, 0x3b, 0x3b,
	0x53, 0x38, 0xff, 0x23, 0xc3, 0x59, 0xe4, 0xdc, 0x71, 0x37, 0xf6, 0x79, 0x68, 0x17, 0x4e, 0x96,
	0x0a, 0xa5, 0x96, 0x78, 0x5a, 0x00, 0x3b, 0x2f, 0x3d, 0x29, 0x3d, 0x9f, 0xdb, 0x69, 0x70, 0x12,
	0x4f, 0x6d, 0x2d, 0x02, 0x1e, 0x69, 0x16, 0xa8, 0x8c, 0xdf, 0x39, 0xdb, 0x26, 0xf0, 0x40, 0xe9,
	0x45, 0x16, 0x24, 0xff, 0x0c, 0x30, 0x7f, 0xc8, 0x70, 0x86, 0xef, 0xa0, 0x1e, 0xc9, 0x38, 0x74,
	0x78, 0xdb, 0xe8, 0x1a, 0xbd, 0x66, 0xff, 0x99, 0x55, 0xd4, 0x4e, 0x48, 0xe3, 0x94, 0x40, 0x97,
	0x44, 0x44, 0x30, 0x5d, 0xa6, 0x59, 0xbb, 0xda, 0x35, 0x7a, 0x27, 0x34, 0xfd, 0xc6, 0x17, 0x00,
	0xae, 0x08, 0xb9, 0xa3, 0x85, 0x9c, 0x47, 0xed, 0x5a, 0x1a, 0xd9, 0x40, 0xf0, 0x39, 0x1c, 0x87,
	0x9c, 0x69, 0x9d, 0x78, 0x68, 0x9b, 0x5d, 0xa3, 0xd7, 0xa0, 0x39, 0x40, 0x5e, 0x01, 0xe4, 0x3a,
	0xd8, 0x2a, 0x58, 0x3a, 0x5e, 0xe9, 0x92, 0xcf, 0xd0, 0xbc, 0x66, 0x1e, 0xe5, 0x91, 0x92, 0xf3,
	0x88, 0xe3, 0x00, 0x1a, 0xc1, 0xe2, 0xd7, 0x54, 0x70, 0xdf, 0x5d, 0x7a, 0xef, 0x58, 0xd9, 0x95,
	0xad, 0xd5, 0x95, 0xad, 0xdb, 0x55, 0x4f, 0xe8, 0xa3, 0x60, 0x71, 0x95, 0x50, 0xc9, 0x30, 0xd3,
	0xfa, 0x1e, 0x6b, 0x15, 0x6b, 0x7c, 0x03, 0x55, 0x91, 0xa7, 0x17, 0xaf, 0xfe, 0x95, 0x4d, 0x67,
	0x2c, 0xe3, 0xd1, 0xaa, 0x70, 0xc9, 0x6f, 0x68, 0x6e, 0x40, 0x78, 0x03, 0x38, 0x4b, 0x8e, 0xb7,
	0x52, 0x09, 0xe7, 0x1b, 0x8f, 0x22, 0xe6, 0xf1, 0xa8, 0x6d, 0x74, 0x6b, 0xbd, 0x66, 0xff, 0xbc,
	0xac, 0x54, 0x81, 0x48, 0x4b, 0x92, 0xc9, 0x5f, 0xc0, 0x5d, 0x26, 0x3e, 0x85, 0x23, 0x9d, 0x00,
	0xcb, 0x76, 0x64, 0x07, 0x1c, 0xc3, 0x63, 0xc5, 0x42, 0x2d, 0x92, 0xfe, 0xae, 0xd5, 0xab, 0xa9,
	0xfa, 0xeb, 0x32, 0xf5, 0xd1, 0x36, 0x99, 0xee, 0xe6, 0x13, 0x09, 0xad, 0x72, 0x72, 0xf2, 0x80,
	0x6b, 0x7a, 0x6a, 0xe4, 0x88, 0xe6, 0x00, 0xbe, 0x87, 0x46, 0x50, 0xf4, 0x70, 0x56, 0xe6, 0x61,
	0x59, 0x8d, 0xae, 0xc9, 0x84, 0xc0, 0xc9, 0x66, 0x64, 0x3d, 0x5b, 0x46, 0x3e, 0x5b, 0xfd, 0xff,
	0x35, 0x38, 0x4d, 0xc7, 0x63, 0x55, 0x0c, 0x07, 0x60, 0x8e, 0xa4, 0xef, 0x63, 0x6b, 0xe7, 0xc1,
	0xbf, 0x24, 0x33, 0xde, 0x79, 0x52, 0x32, 0xc4, 0xa4, 0x82, 0x43, 0x30, 0x47, 0x62, 0xee, 0xed,
	0x4d, 0xdb, 0x83, 0x93, 0x0a, 0x7e, 0x84, 0xfa, 0x15, 0x13, 0x3e, 0x77, 0x71, 0xff, 0x7e, 0x1c,
	0x48, 0xbf, 0x84, 0xc6, 0x27, 0x19, 0x28, 0x9f, 0x6b, 0x7e, 0xa8, 0x40, 0x59, 0x28, 0x1b, 0xb6,
	0xcc, 0xfc, 0x4d, 0x2c, 0xf4, 0x03, 0xcc, 0x0f, 0xc1, 0x1c, 0x6b, 0xa9, 0x1e, 0x90, 0xf9, 0x01,
	0x6a, 0xd7, 0x6c, 0x7f, 0xbf, 0xb6, 0x17, 0x66, 0x63, 0x3b, 0x49, 0xe5, 0x72, 0xf0, 0xf3, 0xc2,
	0x13, 0xfa, 0x2e, 0x9e, 0x58, 0x8e, 0x0c, 0x6c, 0x2d, 0x5c, 0xae, 0xa4, 0xf4, 0xdf, 0xca, 0xd0,
	0xb3, 0x0f, 0xfc, 0xec, 0x26, 0xf5, 0x54, 0xe4, 0xe2, 0x3e, 0x00, 0x00, 0xff, 0xff, 0x74, 0x79,
	0xf2, 0x63, 0x12, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// WorkSchedulerClient is the client API for WorkScheduler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WorkSchedulerClient interface {
	// Retrieve work to be performed
	Poll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Work, error)
	// confirm that work scheduler is alive
	Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// report to work scheduler that a work item failed
	Failed(ctx context.Context, in *WorkSource, opts ...grpc.CallOption) (*empty.Empty, error)
	// report to work scheduler that a work item is completed
	Complete(ctx context.Context, in *WorkSource, opts ...grpc.CallOption) (*WorkOutput, error)
	// cause work scheduler to exit
	Quit(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// cause work scheduler to stop providing work
	Stop(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	Lag(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*LagResponse, error)
}

type workSchedulerClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkSchedulerClient(cc grpc.ClientConnInterface) WorkSchedulerClient {
	return &workSchedulerClient{cc}
}

func (c *workSchedulerClient) Poll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Work, error) {
	out := new(Work)
	err := c.cc.Invoke(ctx, "/workscheduler.WorkScheduler/Poll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workSchedulerClient) Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/workscheduler.WorkScheduler/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workSchedulerClient) Failed(ctx context.Context, in *WorkSource, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/workscheduler.WorkScheduler/Failed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workSchedulerClient) Complete(ctx context.Context, in *WorkSource, opts ...grpc.CallOption) (*WorkOutput, error) {
	out := new(WorkOutput)
	err := c.cc.Invoke(ctx, "/workscheduler.WorkScheduler/Complete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workSchedulerClient) Quit(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/workscheduler.WorkScheduler/Quit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workSchedulerClient) Stop(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/workscheduler.WorkScheduler/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workSchedulerClient) Lag(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*LagResponse, error) {
	out := new(LagResponse)
	err := c.cc.Invoke(ctx, "/workscheduler.WorkScheduler/Lag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkSchedulerServer is the server API for WorkScheduler service.
type WorkSchedulerServer interface {
	// Retrieve work to be performed
	Poll(context.Context, *empty.Empty) (*Work, error)
	// confirm that work scheduler is alive
	Ping(context.Context, *empty.Empty) (*empty.Empty, error)
	// report to work scheduler that a work item failed
	Failed(context.Context, *WorkSource) (*empty.Empty, error)
	// report to work scheduler that a work item is completed
	Complete(context.Context, *WorkSource) (*WorkOutput, error)
	// cause work scheduler to exit
	Quit(context.Context, *empty.Empty) (*empty.Empty, error)
	// cause work scheduler to stop providing work
	Stop(context.Context, *empty.Empty) (*empty.Empty, error)
	Lag(context.Context, *empty.Empty) (*LagResponse, error)
}

// UnimplementedWorkSchedulerServer can be embedded to have forward compatible implementations.
type UnimplementedWorkSchedulerServer struct {
}

func (*UnimplementedWorkSchedulerServer) Poll(ctx context.Context, req *empty.Empty) (*Work, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Poll not implemented")
}
func (*UnimplementedWorkSchedulerServer) Ping(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (*UnimplementedWorkSchedulerServer) Failed(ctx context.Context, req *WorkSource) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Failed not implemented")
}
func (*UnimplementedWorkSchedulerServer) Complete(ctx context.Context, req *WorkSource) (*WorkOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Complete not implemented")
}
func (*UnimplementedWorkSchedulerServer) Quit(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Quit not implemented")
}
func (*UnimplementedWorkSchedulerServer) Stop(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (*UnimplementedWorkSchedulerServer) Lag(ctx context.Context, req *empty.Empty) (*LagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lag not implemented")
}

func RegisterWorkSchedulerServer(s *grpc.Server, srv WorkSchedulerServer) {
	s.RegisterService(&_WorkScheduler_serviceDesc, srv)
}

func _WorkScheduler_Poll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkSchedulerServer).Poll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workscheduler.WorkScheduler/Poll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkSchedulerServer).Poll(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkScheduler_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkSchedulerServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workscheduler.WorkScheduler/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkSchedulerServer).Ping(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkScheduler_Failed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkSource)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkSchedulerServer).Failed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workscheduler.WorkScheduler/Failed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkSchedulerServer).Failed(ctx, req.(*WorkSource))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkScheduler_Complete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkSource)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkSchedulerServer).Complete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workscheduler.WorkScheduler/Complete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkSchedulerServer).Complete(ctx, req.(*WorkSource))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkScheduler_Quit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkSchedulerServer).Quit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workscheduler.WorkScheduler/Quit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkSchedulerServer).Quit(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkScheduler_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkSchedulerServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workscheduler.WorkScheduler/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkSchedulerServer).Stop(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkScheduler_Lag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkSchedulerServer).Lag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/workscheduler.WorkScheduler/Lag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkSchedulerServer).Lag(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _WorkScheduler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "workscheduler.WorkScheduler",
	HandlerType: (*WorkSchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Poll",
			Handler:    _WorkScheduler_Poll_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _WorkScheduler_Ping_Handler,
		},
		{
			MethodName: "Failed",
			Handler:    _WorkScheduler_Failed_Handler,
		},
		{
			MethodName: "Complete",
			Handler:    _WorkScheduler_Complete_Handler,
		},
		{
			MethodName: "Quit",
			Handler:    _WorkScheduler_Quit_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _WorkScheduler_Stop_Handler,
		},
		{
			MethodName: "Lag",
			Handler:    _WorkScheduler_Lag_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "workscheduler/workscheduler.proto",
}
